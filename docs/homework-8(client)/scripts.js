/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/global/scripts/index.ts");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/webpack/buildin/global.js":
/*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("var g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || Function(\"return this\")() || (1, eval)(\"this\");\n} catch (e) {\n\t// This works if the window reference is available\n\tif (typeof window === \"object\") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n\n\n//# sourceURL=webpack:///(webpack)/buildin/global.js?");

/***/ }),

/***/ "./src/components/general/header/header.ts":
/*!*************************************************!*\
  !*** ./src/components/general/header/header.ts ***!
  \*************************************************/
/*! exports provided: toggleHeader */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"toggleHeader\", function() { return toggleHeader; });\n/* harmony import */ var _global_scripts_globalHelper__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../global/scripts/globalHelper */ \"./src/global/scripts/globalHelper.ts\");\n\r\nfunction toggleHeader() {\r\n    if (_global_scripts_globalHelper__WEBPACK_IMPORTED_MODULE_0__[\"globalHelper\"].getViewPortSizes()[0] < 630) {\r\n        const menu = document.querySelectorAll('.menu_list_header')[0];\r\n        if (menu.classList.contains('animation_slide_on')) {\r\n            menu.classList.remove('animation_slide_on');\r\n            menu.classList.add('animation_slide_off');\r\n            setTimeout(function () {\r\n                menu.classList.remove('animation_slide_off', 'menu_list_item_header--active');\r\n            }, 300);\r\n        }\r\n        else {\r\n            menu.classList.add('animation_slide_on', 'menu_list_item_header--active');\r\n        }\r\n    }\r\n}\r\nconst menuContainer = document.querySelector('.header__container');\r\nif (menuContainer) {\r\n    menuContainer.addEventListener('click', toggleHeader);\r\n}\r\n\n\n//# sourceURL=webpack:///./src/components/general/header/header.ts?");

/***/ }),

/***/ "./src/components/library/camera/camera.ts":
/*!*************************************************!*\
  !*** ./src/components/library/camera/camera.ts ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nclass CameraController {\r\n    constructor(element, url) {\r\n        /* videoState */\r\n        this.streamUrl = url;\r\n        this.animationLength = 250;\r\n        this.animationStart = false;\r\n        this.video = element;\r\n        this.videoWrapper = this.video.parentElement;\r\n        if (!this.videoWrapper) {\r\n            throw Error('Vide wrapper doesn`t exist');\r\n        }\r\n        this.cardContainer = this.videoWrapper.parentElement;\r\n        this.cardsContainer = this.cardContainer.parentElement;\r\n        if (!this.cardContainer || !this.cardsContainer || !this.videoWrapper) {\r\n            throw Error('Bad params');\r\n        }\r\n        this.videoControllers = this.videoWrapper.lastElementChild;\r\n        if (!this.videoControllers.firstElementChild || !this.videoControllers.lastElementChild) {\r\n            throw Error('Bad videoControllers');\r\n        }\r\n        this.brightController = this.videoControllers.firstElementChild.children[0];\r\n        this.contrastController = this.videoControllers.firstElementChild.children[1];\r\n        this.soundLevelController = this.videoControllers.lastElementChild.children[0];\r\n        this.backButtonController = this.videoControllers.lastElementChild.children[1];\r\n        this.brightness = 100;\r\n        this.contrast = 100;\r\n        this.opened = false;\r\n        this.containerSize = {\r\n            calculated: false,\r\n            generalContainer: {\r\n                top: 0,\r\n                left: 0,\r\n                width: 0,\r\n                height: 0\r\n            },\r\n            videoContainer: {\r\n                top: 0,\r\n                left: 0,\r\n                width: 0,\r\n                height: 0\r\n            }\r\n        };\r\n        this.hlsSupported = Hls.isSupported();\r\n        this.init();\r\n    }\r\n    init() {\r\n        this.startStream(this.streamUrl);\r\n        /* define directions for this.directionX and this.directionY */\r\n        this.defineAnimationDirections();\r\n        this.changeBrightness(this.brightness);\r\n        if (this.video) {\r\n            this.video.addEventListener('click', () => {\r\n                if (this.opened) {\r\n                    this.close();\r\n                }\r\n                else {\r\n                    this.open();\r\n                }\r\n            });\r\n            window.addEventListener(\"resize\", this.onResize.bind(this), false);\r\n        }\r\n        if (this.brightController) {\r\n            this.brightController.addEventListener('change', this.onBrightnessChange.bind(this));\r\n        }\r\n        if (this.contrastController) {\r\n            this.contrastController.addEventListener('change', this.onContrastChange.bind(this));\r\n        }\r\n        if (this.backButtonController) {\r\n            this.backButtonController.addEventListener('click', this.close.bind(this));\r\n        }\r\n    }\r\n    initAudioAnalyser() {\r\n        /* Audio context*/\r\n        let AudioContext = window.AudioContext || window.webkitAudioContext;\r\n        this.audioCtx = new AudioContext();\r\n        this.node = this.audioCtx.createScriptProcessor(2048, 1, 1);\r\n        /* Analyzer */\r\n        this.analyser = this.audioCtx.createAnalyser();\r\n        this.analyser.smoothingTimeConstant = 0.3;\r\n        this.analyser.fftSize = 512;\r\n        this.bands = new Uint8Array(this.analyser.frequencyBinCount);\r\n        /* bindings */\r\n        this.source = this.audioCtx.createMediaElementSource(this.video);\r\n        this.source.connect(this.analyser);\r\n        this.analyser.connect(this.node);\r\n        this.node.connect(this.audioCtx.destination);\r\n        this.source.connect(this.audioCtx.destination);\r\n        /* writing sound data to array */\r\n        this.node.onaudioprocess = () => {\r\n            this.analyser.getByteFrequencyData(this.bands);\r\n        };\r\n    }\r\n    toggleVisualizateSound() {\r\n        if (!this.timer) {\r\n            this.timer = window.setInterval(() => {\r\n                let avgLevel = this.getAverageFromArray(this.bands);\r\n                if (!this.soundLevelController) {\r\n                    throw Error();\r\n                }\r\n                else {\r\n                    this.soundLevelController.style.height = `${avgLevel + 20}px`;\r\n                    this.soundLevelController.innerHTML = String(this.getAverageFromArray(this.bands));\r\n                }\r\n            }, 100);\r\n        }\r\n        else {\r\n            clearInterval(this.timer);\r\n            this.timer = null;\r\n        }\r\n    }\r\n    getAverageFromArray(arr) {\r\n        const sum = arr.reduce(function (a, b) { return a + b; });\r\n        return sum > 0 ? Math.round(sum / arr.length) : 0;\r\n    }\r\n    startStream(url) {\r\n        if (this.hlsSupported) {\r\n            try {\r\n                this.hls = new Hls();\r\n                this.hls.loadSource(url);\r\n                this.hls.attachMedia(this.video);\r\n                this.hls.on(Hls.Events.MANIFEST_PARSED, () => {\r\n                    this.video.play();\r\n                });\r\n            }\r\n            catch (e) {\r\n                console.log(e);\r\n            }\r\n        }\r\n        else if (this.video.canPlayType('application/vnd.apple.mpegurl')) {\r\n            this.video.src = url;\r\n            this.video.addEventListener('loadedmetadata', () => {\r\n                this.video.play();\r\n            });\r\n        }\r\n    }\r\n    /* get true/false */\r\n    changeQualityStream(toQualityMax) {\r\n        if (this.hlsSupported) {\r\n            try {\r\n                let videoQualityLevels = Object.keys(this.hls.levels);\r\n                if (toQualityMax) {\r\n                    this.hls.nextLevel = Number(videoQualityLevels[videoQualityLevels.length - 1]);\r\n                }\r\n                else {\r\n                    this.hls.nextLevel = Number(videoQualityLevels[0]);\r\n                }\r\n            }\r\n            catch (e) {\r\n                console.log(e);\r\n            }\r\n        }\r\n    }\r\n    open() {\r\n        if (!this.opened && !this.animationStart) {\r\n            this.animationStart = true;\r\n            /* set up translate */\r\n            this.toggleTranslate();\r\n            /* scale and translate css */\r\n            this.setContainerTransform();\r\n            /* add z-index class*/\r\n            this.toggleOpenClassName();\r\n            setTimeout(() => {\r\n                this.opened = true;\r\n                this.animationStart = false;\r\n                /* delete transition */\r\n                this.toggleTranslate();\r\n                this.toggleCameraControllers();\r\n                this.changeQualityStream(true);\r\n                !this.source ? this.initAudioAnalyser() : null;\r\n                this.toggleVisualizateSound();\r\n            }, this.animationLength);\r\n        }\r\n    }\r\n    close() {\r\n        if (this.opened && !this.animationStart) {\r\n            this.animationStart = true;\r\n            this.videoWrapper.style.transform = null;\r\n            /* set up translate */\r\n            this.toggleTranslate();\r\n            /* Camera controls*/\r\n            this.toggleCameraControllers();\r\n            /* clear visualization */\r\n            this.toggleVisualizateSound();\r\n            setTimeout(() => {\r\n                /* set up z-index*/\r\n                this.toggleOpenClassName();\r\n                /* set up translate */\r\n                this.toggleTranslate();\r\n                /* up quality stream */\r\n                this.changeQualityStream(false);\r\n                this.opened = false;\r\n                this.animationStart = false;\r\n            }, this.animationLength);\r\n        }\r\n    }\r\n    toggleCameraControllers() {\r\n        if (this.videoControllers.classList.contains('camera_controllers--opened')) {\r\n            this.videoControllers.classList.remove('camera_controllers--opened');\r\n        }\r\n        else {\r\n            this.videoControllers.classList.add('camera_controllers--opened');\r\n        }\r\n    }\r\n    /*delete for preventing slow changes when resizing window*/\r\n    toggleTranslate() {\r\n        if (this.videoWrapper.style.transition) {\r\n            this.videoWrapper.style.transition = null;\r\n        }\r\n        else {\r\n            this.videoWrapper.style.transition = `transform  ${this.animationLength / 1000}s ease-out`;\r\n        }\r\n    }\r\n    toggleOpenClassName() {\r\n        if (this.videoWrapper.classList.contains('opened')) {\r\n            this.videoWrapper.classList.remove('opened');\r\n        }\r\n        else {\r\n            this.videoWrapper.classList.add('opened');\r\n        }\r\n    }\r\n    setContainerTransform() {\r\n        let params = this._calculateTransformParams();\r\n        this.videoWrapper.style.transform = 'scale(' + params.scale + ') translate(' + this.directionX * params.translateX + 'px,' + this.directionY * params.translateY + 'px)';\r\n    }\r\n    onResize() {\r\n        if (this.opened) {\r\n            this.setContainerTransform();\r\n        }\r\n    }\r\n    onBrightnessChange(e) {\r\n        let value = Number(e.target.value) * 2;\r\n        this.changeBrightness(value);\r\n    }\r\n    changeBrightness(value) {\r\n        this.brightness = value;\r\n        this.video.style.filter = `brightness(${value}%) contrast(${this.contrast}%)`;\r\n    }\r\n    onContrastChange(e) {\r\n        let value = Number(e.target.value) * 2;\r\n        this.changeContrast(value);\r\n    }\r\n    changeContrast(value) {\r\n        this.contrast = value;\r\n        this.video.style.filter = `brightness(${this.brightness}%) contrast(${value}%)`;\r\n    }\r\n    defineAnimationDirections() {\r\n        if (!this.containerSize.calculated) {\r\n            this._calculateTransformParams();\r\n        }\r\n        const generalCenterX = this.containerSize.generalContainer.left + this.containerSize.generalContainer.width / 2;\r\n        const generalCenterY = this.containerSize.generalContainer.top + this.containerSize.generalContainer.height / 2;\r\n        const videoCenterX = this.containerSize.videoContainer.left + this.containerSize.videoContainer.width / 2;\r\n        const videoCenterY = this.containerSize.videoContainer.top + this.containerSize.videoContainer.height / 2;\r\n        this.directionX = videoCenterX > generalCenterX ? -1 : 1;\r\n        this.directionY = videoCenterY > generalCenterY ? -1 : 1;\r\n    }\r\n    _calculateTransformParams() {\r\n        let domRectVideo = this.cardContainer.getBoundingClientRect(), domRectContainer = this.cardsContainer.getBoundingClientRect();\r\n        let videoContainer = {\r\n            top: domRectVideo.top,\r\n            left: domRectVideo.left,\r\n            width: domRectVideo.width,\r\n            height: domRectVideo.height\r\n        };\r\n        let generalContainer = {\r\n            top: domRectContainer.top,\r\n            left: domRectContainer.left,\r\n            width: domRectContainer.width,\r\n            height: domRectContainer.height\r\n        };\r\n        this.containerSize = {\r\n            calculated: true,\r\n            videoContainer: videoContainer,\r\n            generalContainer: generalContainer\r\n        };\r\n        const scale = Math.ceil(generalContainer.width / videoContainer.width * 10) / 10;\r\n        return {\r\n            scale: scale,\r\n            translateX: Math.ceil(videoContainer.width * (scale - 1) / 4 - Math.ceil((videoContainer.width * scale - generalContainer.width) / 2)),\r\n            translateY: Math.ceil(videoContainer.height * (scale - 1) / 4 - Math.ceil((videoContainer.height * scale - generalContainer.height) / 2))\r\n        };\r\n    }\r\n}\r\nlet cameras = document.querySelectorAll('.camera video');\r\nlet streams = [\r\n    'http://localhost:9191/master?url=http%3A%2F%2Flocalhost%3A3102%2Fstreams%2Fsosed%2Fmaster.m3u8',\r\n    'http://localhost:9191/master?url=http%3A%2F%2Flocalhost%3A3102%2Fstreams%2Fcat%2Fmaster.m3u8',\r\n    'http://localhost:9191/master?url=http%3A%2F%2Flocalhost%3A3102%2Fstreams%2Fdog%2Fmaster.m3u8',\r\n    'http://localhost:9191/master?url=http%3A%2F%2Flocalhost%3A3102%2Fstreams%2Fhall%2Fmaster.m3u8'\r\n];\r\ncameras.forEach((camera, index) => new CameraController(camera, streams[index]));\r\n\n\n//# sourceURL=webpack:///./src/components/library/camera/camera.ts?");

/***/ }),

/***/ "./src/components/library/card/card.ts":
/*!*********************************************!*\
  !*** ./src/components/library/card/card.ts ***!
  \*********************************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _global_scripts_globalHelper__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../global/scripts/globalHelper */ \"./src/global/scripts/globalHelper.ts\");\n\r\nif (_global_scripts_globalHelper__WEBPACK_IMPORTED_MODULE_0__[\"globalHelper\"].checkTouchDevice()) {\r\n    const touchElements = document.querySelector('.touch_elements');\r\n    if (touchElements) {\r\n        touchElements.style.display = 'flex';\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack:///./src/components/library/card/card.ts?");

/***/ }),

/***/ "./src/components/library/menu/menu.ts":
/*!*********************************************!*\
  !*** ./src/components/library/menu/menu.ts ***!
  \*********************************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _general_header_header__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../general/header/header */ \"./src/components/general/header/header.ts\");\n\r\nconst menuItems = document.querySelectorAll('.menu_list_item_header');\r\nmenuItems.forEach(function (menuItem) {\r\n    menuItem.addEventListener('click', onMenuItemClick, true);\r\n});\r\nfunction onMenuItemClick(e) {\r\n    let active = document.querySelectorAll('.menu_list_item_header--active')[0];\r\n    active.classList.remove('menu_list_item_header--active');\r\n    if (e.target.parentElement) {\r\n        const parent = e.target.parentElement;\r\n        if (parent) {\r\n            parent.classList.add('menu_list_item_header--active');\r\n        }\r\n    }\r\n    Object(_general_header_header__WEBPACK_IMPORTED_MODULE_0__[\"toggleHeader\"])();\r\n    e.stopPropagation();\r\n}\r\n\n\n//# sourceURL=webpack:///./src/components/library/menu/menu.ts?");

/***/ }),

/***/ "./src/components/library/player/player.ts":
/*!*************************************************!*\
  !*** ./src/components/library/player/player.ts ***!
  \*************************************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _framework_Store__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../framework/Store */ \"./src/framework/Store.ts\");\n\r\nconst initialState = {\r\n    currentTrack: {\r\n        id: null,\r\n        length: 0,\r\n        image: '',\r\n        bandName: '',\r\n        trackName: '',\r\n    },\r\n    playerParams: {\r\n        currentTime: 0,\r\n        volume: 80\r\n    },\r\n    nowUpdating: false\r\n};\r\nconst CHANGE_PLAYER_PARAM = 'CHANGE_PLAYER_PARAM';\r\nconst TOGGLE_LOADER = 'TOGGLE_LOADER';\r\nconst GET_TRACK = 'GET_TRACK';\r\n/* handlers */\r\nconst handlers = [];\r\nconst changePlayerParamHandler = {\r\n    name: CHANGE_PLAYER_PARAM,\r\n    sync: true,\r\n    handler: (data, state, done) => {\r\n        done({ playerParams: { [data.param]: data.value } });\r\n    }\r\n};\r\nhandlers.push(changePlayerParamHandler);\r\nconst toggleLoader = {\r\n    name: TOGGLE_LOADER,\r\n    sync: true,\r\n    handler: (data, state, done) => {\r\n        done({ nowUpdating: !state.nowUpdating });\r\n    }\r\n};\r\nhandlers.push(toggleLoader);\r\nconst getTrackHandler = {\r\n    name: GET_TRACK,\r\n    sync: false,\r\n    handler: (data, state, done) => {\r\n        const currentTrackId = state.currentTrack.id;\r\n        fetch('http://localhost:8080/api/player', {\r\n            method: 'post',\r\n            headers: {\r\n                'Accept': 'application/json, text/plain, */*',\r\n                'Content-Type': 'application/json'\r\n            },\r\n            body: JSON.stringify({ currentTrackId })\r\n        }).then(res => res.json())\r\n            .then(json => {\r\n            if (json.status === 'ok') {\r\n                done({ currentTrack: Object.assign({}, json.track) });\r\n            }\r\n        });\r\n    }\r\n};\r\nhandlers.push(getTrackHandler);\r\n/* handlers end */\r\n/* views */\r\nconst views = [];\r\n/* todo check extended class */\r\n/* Логгер в консоль */\r\nconst logger = (state) => {\r\n    console.log(state);\r\n};\r\nviews.push(logger);\r\n/* Трек */\r\nconst trackView = (state) => {\r\n    const img = document.querySelector('.track > img');\r\n    if (img) {\r\n        img.src = state.currentTrack.image || '';\r\n    }\r\n    const trackLengthElement = document.querySelector('.track__time');\r\n    if (trackLengthElement) {\r\n        trackLengthElement.innerHTML = `${Math.floor(state.currentTrack.length / 60)}:${Math.floor(state.currentTrack.length % 60)} `;\r\n    }\r\n    const trackNameElem = document.querySelector('.track__name');\r\n    if (trackNameElem) {\r\n        trackNameElem.innerText = `${state.currentTrack.bandName} - ${state.currentTrack.trackName}`;\r\n    }\r\n};\r\nviews.push(trackView);\r\n/* Прелоадер */\r\nconst preloaderView = (state) => {\r\n    const preloader = document.getElementsByClassName('player__preloader')[0];\r\n    if (state.nowUpdating) {\r\n        preloader.style.display = 'block';\r\n    }\r\n    else {\r\n        preloader.style.display = 'none';\r\n    }\r\n};\r\nviews.push(preloaderView);\r\n/* Уровень звука */\r\nconst volume = (state) => {\r\n    const volumeLevel = document.getElementsByClassName('volume__value')[0];\r\n    volumeLevel.innerText = `${state.playerParams.volume}%`;\r\n};\r\nviews.push(volume);\r\n/* views end*/\r\n/* store init */\r\nconst musicCard = document.getElementsByClassName('card--music')[0];\r\nif (musicCard) {\r\n    const preloader = document.createElement('div');\r\n    preloader.style.display = 'none';\r\n    preloader.classList.add('player__preloader');\r\n    musicCard.prepend(preloader);\r\n}\r\nconst store = new _framework_Store__WEBPACK_IMPORTED_MODULE_0__[\"Store\"](initialState, handlers, views);\r\n/* store end */\r\n/* actions */\r\nconst changePlayerParamAction = (param, value) => store.dispatch({\r\n    action_type: CHANGE_PLAYER_PARAM,\r\n    data: {\r\n        param,\r\n        value\r\n    }\r\n});\r\nconst getTrackAction = () => store.multipleDispatch([\r\n    {\r\n        action_type: TOGGLE_LOADER\r\n    },\r\n    {\r\n        action_type: GET_TRACK\r\n    },\r\n    {\r\n        action_type: TOGGLE_LOADER\r\n    }\r\n]);\r\n/* actions */\r\n/* Code */\r\n/*Получаем первый трек */\r\ngetTrackAction();\r\n/* Слушатели на кнопках */\r\nconst trackControllers = document.querySelectorAll('.track_control > img');\r\ntrackControllers.forEach(trackController => {\r\n    trackController.addEventListener('click', getTrackAction);\r\n});\r\n/* Инпуты */\r\nconst volumeRange = document.getElementsByClassName('volume_range')[0];\r\nif (volumeRange) {\r\n    volumeRange.addEventListener('change', (e) => {\r\n        const value = e.target.value;\r\n        changePlayerParamAction('volume', value);\r\n    });\r\n}\r\n\n\n//# sourceURL=webpack:///./src/components/library/player/player.ts?");

/***/ }),

/***/ "./src/components/library/touch-elements/touch-elements.ts":
/*!*****************************************************************!*\
  !*** ./src/components/library/touch-elements/touch-elements.ts ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nclass ImageTouchEvents {\r\n    constructor(image, options) {\r\n        this.image = image;\r\n        if (!image.parentElement) {\r\n            throw new Error(\"Can't find parent for image\");\r\n        }\r\n        this.parent = image.parentElement;\r\n        this.image.onload = () => {\r\n            this.initListeners();\r\n            this.initState();\r\n            this.initOutput(options);\r\n        };\r\n    }\r\n    initListeners() {\r\n        this.image.addEventListener('pointerdown', (e) => {\r\n            this.image.setPointerCapture(e.pointerId);\r\n            this.addTouchPointer(e);\r\n        });\r\n        this.image.addEventListener('pointermove', (e) => {\r\n            if (this.activePoints[e.pointerId]) {\r\n                this.calculateTouchCore(e);\r\n            }\r\n        });\r\n        this.image.addEventListener('pointercancel', (e) => this.removeTouchPointer(e));\r\n        this.image.addEventListener('pointerup', (e) => this.removeTouchPointer(e));\r\n    }\r\n    /* this method init state params  */\r\n    initState() {\r\n        const initParams = this.image.getBoundingClientRect();\r\n        const that = this;\r\n        this.activePoints = {};\r\n        this.options = {\r\n            maxScrollX: initParams.right - initParams.left - that.parent.offsetWidth,\r\n            maxScrollY: initParams.bottom - initParams.top - that.parent.offsetHeight,\r\n            width: initParams.right - initParams.left,\r\n            height: initParams.bottom - initParams.top,\r\n            startX: 0,\r\n            startY: 0,\r\n            prevX: 0,\r\n            prevY: 0,\r\n            currentTouchAction: null,\r\n            currentBgFilter: 100,\r\n            zoomCurrent: 1,\r\n            zoomMax: 2,\r\n            zoomMin: 1\r\n        };\r\n    }\r\n    setIfExist(selector) {\r\n        let element = document.querySelector(selector);\r\n        if (!element) {\r\n            throw Error(`Can't find element by selector ${selector} `);\r\n        }\r\n        else {\r\n            return element;\r\n        }\r\n    }\r\n    initOutput(options) {\r\n        const that = this;\r\n        this.output = {\r\n            zoom: this.setIfExist(options.zoom),\r\n            bright: this.setIfExist(options.bright),\r\n            vMove: this.setIfExist(options.vMove),\r\n            hMove: this.setIfExist(options.hMove),\r\n        };\r\n        function setValueToContainer(container, delimiter) {\r\n            return function (value) {\r\n                container.innerHTML = `${Math.abs(Math.round(value / delimiter * 100))}%`;\r\n            };\r\n        }\r\n        this.triggers = {\r\n            zoomCurrent: setValueToContainer(that.output.zoom, 1),\r\n            prevX: setValueToContainer(that.output.vMove, that.options.maxScrollX),\r\n            prevY: setValueToContainer(that.output.hMove, that.options.maxScrollY),\r\n            currentBgFilter: setValueToContainer(that.output.bright, 100),\r\n        };\r\n    }\r\n    setOption(option, value) {\r\n        this.options[option] = value;\r\n        if (this.triggers[option] && value && typeof value !== \"string\") {\r\n            this.triggers[option](value);\r\n        }\r\n    }\r\n    getOption(option) {\r\n        return this.options[option];\r\n    }\r\n    /* this method handle pointerup action */\r\n    addTouchPointer(e) {\r\n        let pointCount = Object.keys(this.activePoints).length;\r\n        if (pointCount > 1) {\r\n            return;\r\n        }\r\n        this.activePoints[e.pointerId] = {\r\n            prevX: e.x,\r\n            prevY: e.y,\r\n            startX: e.x,\r\n            startY: e.y,\r\n            prevTs: Date.now(),\r\n        };\r\n    }\r\n    ;\r\n    removeTouchPointer(e) {\r\n        this.setOption('currentTouchAction', null);\r\n        delete this.activePoints[e.pointerId];\r\n    }\r\n    ;\r\n    /* this method calculate core params  */\r\n    calculateTouchCore(e) {\r\n        if (!this.activePoints[e.pointerId]) {\r\n            return;\r\n        }\r\n        const currentPoint = this.activePoints[e.pointerId];\r\n        const that = this;\r\n        /* throttling */\r\n        const ts = Date.now(), run = ts - currentPoint.prevTs > 4;\r\n        if (!run) {\r\n            return;\r\n        }\r\n        const x = e.x;\r\n        const y = e.y;\r\n        const top = this.getOption('prevY');\r\n        const left = this.getOption('prevX');\r\n        const touchParams = {\r\n            detX: x - currentPoint.prevX,\r\n            detY: y - currentPoint.prevY,\r\n            currentPoint: currentPoint,\r\n            secondPoint: that.getSecondPoint(e.pointerId),\r\n            newPoint: { prevY: y, prevX: x, prevTs: ts, startX: x, startY: y }\r\n        };\r\n        const updateState = () => {\r\n            this.activePoints[e.pointerId] = touchParams.newPoint;\r\n        };\r\n        const newY = (top + touchParams.detY);\r\n        const newX = (left + touchParams.detX);\r\n        let action = this.actionResolver(touchParams);\r\n        if (action === null) {\r\n            return;\r\n        }\r\n        this.setOption('currentTouchAction', action);\r\n        switch (action) {\r\n            case 'swipe':\r\n                {\r\n                    this.handleSwipe(newX, newY, touchParams.detY);\r\n                    updateState();\r\n                }\r\n                break;\r\n            case 'pinch':\r\n                {\r\n                    this.handlePinch(touchParams.currentPoint, touchParams.newPoint, touchParams.secondPoint);\r\n                    updateState();\r\n                }\r\n                break;\r\n            case 'rotate': {\r\n                this.handleRotate(touchParams.detX, touchParams.detY);\r\n            }\r\n            default: {\r\n                return;\r\n            }\r\n        }\r\n    }\r\n    /* this method calculate ange between new and old points */\r\n    calculateAngle(pA, pAn, pB) {\r\n        let cosA, aV, bV;\r\n        if (!(pA.prevX - pAn.prevX + pA.prevY - pA.prevY)) {\r\n            return 1;\r\n        }\r\n        else {\r\n            aV = {\r\n                x: pA.prevX - pB.prevX,\r\n                y: pA.prevY - pB.prevY\r\n            };\r\n            bV = {\r\n                x: pAn.prevX - pB.prevX,\r\n                y: pAn.prevY - pB.prevY\r\n            };\r\n            cosA = (aV.x * bV.x + aV.y * bV.y)\r\n                / Math.sqrt(Math.pow(aV.x, 2) + Math.pow(aV.y, 2))\r\n                / Math.sqrt(Math.pow(bV.x, 2) + Math.pow(bV.y, 2));\r\n        }\r\n        return Math.acos(cosA) * 180 / Math.PI;\r\n    }\r\n    ;\r\n    /* this method define current action */\r\n    actionResolver(options) {\r\n        let currentAction = this.getOption('currentTouchAction');\r\n        let touchCount = Object.keys(this.activePoints).length;\r\n        /* when 2 finders on the device we will once define touch action */\r\n        if (currentAction !== null) {\r\n            return currentAction;\r\n        }\r\n        if (touchCount === 1) {\r\n            this.setOption('currentTouchAction', 'swipe');\r\n            currentAction = 'swipe';\r\n            /* when 2 finders on the device we not updating x and y, to collect detX and detY to define angle*/\r\n        }\r\n        else if (touchCount === 2 && ((Math.abs(options.detX) + Math.abs(options.detY) > 30) && options.secondPoint)) {\r\n            let angle = this.calculateAngle(options.currentPoint, options.newPoint, options.secondPoint);\r\n            /* experimental value */\r\n            if (Math.abs(angle) < 7) {\r\n                this.setOption('currentTouchAction', 'pinch');\r\n                currentAction = 'pinch';\r\n            }\r\n            else {\r\n                this.setOption('currentTouchAction', 'rotate');\r\n                currentAction = 'rotate';\r\n            }\r\n        }\r\n        return currentAction;\r\n    }\r\n    getSecondPoint(firstPointId) {\r\n        for (let pointId in this.activePoints) {\r\n            if (this.activePoints.hasOwnProperty(pointId)) {\r\n                if (Number(pointId) !== Number(firstPointId)) {\r\n                    return this.activePoints[pointId];\r\n                }\r\n            }\r\n        }\r\n    }\r\n    ;\r\n    handleSwipe(newX, newY, detY) {\r\n        /* horizontal parent block boundaries*/\r\n        if (newX <= 0 && Math.abs(newX) <= this.getOption('maxScrollX')) {\r\n            this.image.style.left = newX + 'px';\r\n            this.setOption('prevX', newX);\r\n        }\r\n        /* vertical parent block boundaries*/\r\n        if (((detY < 0 && Math.abs(newY) >= 0) || (detY > 0 && newY <= 0)) &&\r\n            Math.abs(newY) <= this.getOption('maxScrollY')) {\r\n            this.image.style.top = newY + 'px';\r\n            this.setOption('prevY', newY);\r\n        }\r\n    }\r\n    handlePinch(currentPoint, newPoint, secondPoint) {\r\n        const fromVector = {\r\n            x: currentPoint.prevX - secondPoint.prevX,\r\n            y: currentPoint.prevY - secondPoint.prevY\r\n        };\r\n        const toVector = {\r\n            x: newPoint.prevX - secondPoint.prevX,\r\n            y: newPoint.prevY - secondPoint.prevY\r\n        };\r\n        const lengthFrom = Math.sqrt(Math.pow(fromVector.x, 2) + Math.pow(fromVector.y, 2));\r\n        const lengthTo = Math.sqrt(Math.pow(toVector.x, 2) + Math.pow(toVector.y, 2));\r\n        const trackDiff = lengthTo - lengthFrom;\r\n        let zoom;\r\n        if (trackDiff > 0) {\r\n            zoom = Math.min(this.getOption('zoomMax'), this.getOption('zoomCurrent') + 4 / 100);\r\n        }\r\n        else {\r\n            zoom = Math.max(this.getOption('zoomMin'), this.getOption('zoomCurrent') - 4 / 100);\r\n        }\r\n        this.setOption('zoomCurrent', zoom);\r\n        this.image.style.zoom = `${zoom}%`;\r\n    }\r\n    handleRotate(detX, detY) {\r\n        let angle = Math.atan(detX / detY) * 180 / Math.PI;\r\n        let bgFilter;\r\n        if (angle < 0) {\r\n            bgFilter = Math.max(1, this.getOption('currentBgFilter') + angle / 15);\r\n        }\r\n        else {\r\n            bgFilter = Math.min(100, this.getOption('currentBgFilter') + angle / 15);\r\n        }\r\n        this.setOption('currentBgFilter', bgFilter);\r\n        this.image.style.filter = 'brightness(' + bgFilter + '%)';\r\n    }\r\n    ;\r\n}\r\nlet image = document.querySelectorAll('#touch-image > img')[0];\r\nlet options = {\r\n    bright: '#bright',\r\n    zoom: '#zoom',\r\n    vMove: '#vMove',\r\n    hMove: '#hMove'\r\n};\r\nif (image) {\r\n    new ImageTouchEvents(image, options);\r\n}\r\n\n\n//# sourceURL=webpack:///./src/components/library/touch-elements/touch-elements.ts?");

/***/ }),

/***/ "./src/framework/MultipleDispatch.ts":
/*!*******************************************!*\
  !*** ./src/framework/MultipleDispatch.ts ***!
  \*******************************************/
/*! exports provided: MultipleDispatch */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* WEBPACK VAR INJECTION */(function(global) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MultipleDispatch\", function() { return MultipleDispatch; });\nclass MultipleDispatch {\r\n    constructor(options) {\r\n        this.id = options.id;\r\n        this.dispatches = options.dispatches;\r\n        this.handlers = options.storeHandlers;\r\n        this.syncQueue = [];\r\n        this.asyncQueue = [];\r\n        this.statePoints = {};\r\n        this.lastSyncDispatchState = null;\r\n        this.asyncQueueDone = true;\r\n        this.operationId = 0;\r\n        this.temporaryState = Object.assign({}, options.state);\r\n        this.state = options.state;\r\n        this.getOperationId = this.getOperationId.bind(this);\r\n        this.done = options.done;\r\n        this.doneSync = this.doneSync.bind(this);\r\n        this.doneAsync = this.doneAsync.bind(this);\r\n        this.makeQueues();\r\n        this.runQueues();\r\n    }\r\n    /* Формируем 2 очереди, зависимую от потока - синхронную и независимую от сосстояния - асинхронную */\r\n    makeQueues() {\r\n        this.dispatches.map((dispatch) => {\r\n            const operationId = this.getOperationId();\r\n            if (this.handlers[dispatch.action_type].isSync()) {\r\n                this.syncQueue.push(withOperationId(dispatch, operationId));\r\n            }\r\n            else {\r\n                this.asyncQueue.push(withOperationId(dispatch, operationId));\r\n                this.statePoints[operationId] = null;\r\n            }\r\n        });\r\n    }\r\n    /* Запускаем очереди */\r\n    runQueues() {\r\n        this.asyncQueueRun();\r\n        this.syncQueueRun();\r\n    }\r\n    /* Метод, сигнализирующий о завершении синхронной операции*/\r\n    doneSync(state) {\r\n        const withAsyncAction = !!this.asyncQueue.length;\r\n        const lastSyncAction = this.currentSyncDispatcher.operationId === this.syncQueue[this.syncQueue.length - 1].operationId;\r\n        if (!withAsyncAction) {\r\n            this.state = this.done(state);\r\n        }\r\n        else if (withAsyncAction && !lastSyncAction) {\r\n            this.state = this.done(state);\r\n        }\r\n        else if (this.isAsyncQueueDone() && lastSyncAction) {\r\n            this.done(this.concatenateAsyncAndSyncState(state));\r\n        }\r\n        else {\r\n            this.lastSyncDispatchState = state;\r\n        }\r\n        this.statePoints[this.currentSyncDispatcher.operationId] = state;\r\n        /* Выбрасываем из общего стека исполнения, иначе будет вызвана до yield */\r\n        global.setTimeout(() => this.syncGenerator.next(), 0);\r\n        return this.state;\r\n    }\r\n    /* Запускатель синхронной очереди */\r\n    syncQueueRun() {\r\n        const that = this;\r\n        const syncGenerator = function* () {\r\n            let index = 0;\r\n            while (index <= that.syncQueue.length - 1) {\r\n                const currentDispatcher = that.syncQueue[index];\r\n                that.currentSyncDispatcher = currentDispatcher;\r\n                that.handlers[currentDispatcher.action_type].run(currentDispatcher.data, that.state, that.doneSync);\r\n                yield index++;\r\n            }\r\n        };\r\n        this.syncGenerator = syncGenerator();\r\n        this.syncGenerator.next();\r\n    }\r\n    /* Метод сохраняет результат асинхронной операции и передает его основному хранилищу */\r\n    doneAsync(state, operationId) {\r\n        this.statePoints[operationId] = Object.assign({}, this.state, state);\r\n        if (this.isAsyncQueueDone() && this.lastSyncDispatchState) {\r\n            this.done(this.concatenateAsyncAndSyncState(this.lastSyncDispatchState));\r\n        }\r\n        else if (this.isAsyncQueueDone() && this.syncQueue.length === 0) {\r\n            this.done(this.concatenateAsyncAndSyncState());\r\n        }\r\n    }\r\n    /* Запускатель асинхронной очереди */\r\n    asyncQueueRun() {\r\n        const that = this;\r\n        this.asyncQueue.map((dispatcher) => {\r\n            const currentAsyncDispatcher = dispatcher;\r\n            let promise = new Promise((resolve, reject) => {\r\n                that.handlers[dispatcher.action_type].run(dispatcher.data, that.state, resolve);\r\n            });\r\n            promise.then(state => that.doneAsync(state, currentAsyncDispatcher.operationId));\r\n        });\r\n    }\r\n    /* Чекер, что асинхронные операции завершились */\r\n    isAsyncQueueDone() {\r\n        for (let operationId in this.statePoints) {\r\n            if (this.statePoints[operationId] === null) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n    /* Склеиваем слепки состояния от асинхронных операций в порядке их вызова */\r\n    concatenateAsyncAndSyncState(syncState = {}) {\r\n        for (let operationId in this.statePoints) {\r\n            this.temporaryState = Object.assign({}, this.temporaryState, this.statePoints[operationId]);\r\n        }\r\n        return Object.assign({}, this.temporaryState, syncState);\r\n    }\r\n    getOperationId() {\r\n        return this.operationId++;\r\n    }\r\n}\r\nfunction withOperationId(object, operationId) {\r\n    object.operationId = operationId;\r\n    return object;\r\n}\r\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../node_modules/webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\")))\n\n//# sourceURL=webpack:///./src/framework/MultipleDispatch.ts?");

/***/ }),

/***/ "./src/framework/Store.ts":
/*!********************************!*\
  !*** ./src/framework/Store.ts ***!
  \********************************/
/*! exports provided: Store */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Store\", function() { return Store; });\n/* harmony import */ var _StoreHandler__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./StoreHandler */ \"./src/framework/StoreHandler.ts\");\n/* harmony import */ var _MultipleDispatch__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./MultipleDispatch */ \"./src/framework/MultipleDispatch.ts\");\n\r\n\r\n/* Хранилище состояния */\r\nclass Store {\r\n    constructor(initialState, storeHandlers, views) {\r\n        this.state = Object.assign({}, initialState);\r\n        this.views = views;\r\n        this.lastDispatchId = 0;\r\n        this.storeHandlers = {};\r\n        storeHandlers.map((storeHandler) => {\r\n            this.storeHandlers[storeHandler.name] = new _StoreHandler__WEBPACK_IMPORTED_MODULE_0__[\"StoreHandler\"](storeHandler);\r\n        });\r\n        this.allocateState();\r\n        this.multipleDispatchQueue = [];\r\n        this.done = this.done.bind(this);\r\n    }\r\n    /* Метод, который ищет и запускает необходимый обработик */\r\n    updateStore(dispatch) {\r\n        this.storeHandlers[dispatch.action_type].run(dispatch.data, this.state, this.done);\r\n    }\r\n    /* Единственный метод,который может изменить состояние */\r\n    done(state) {\r\n        const newState = Object.assign({}, this.state, state);\r\n        this.state = newState;\r\n        this.allocateState();\r\n        return newState;\r\n    }\r\n    /* диспатчер, обычный, для сихнорнных и асинхронных действий */\r\n    dispatch(dispatch) {\r\n        this.updateStore(dispatch);\r\n    }\r\n    /* сложный диспатчер, содан для объединения сценариев, выполнения последовательности storeHandler */\r\n    multipleDispatch(dispatches) {\r\n        const handlers = {};\r\n        dispatches.map((dispatch) => {\r\n            handlers[dispatch.action_type] = this.storeHandlers[dispatch.action_type];\r\n        });\r\n        const multipleDispatchOptions = {\r\n            state: this.state,\r\n            dispatches,\r\n            storeHandlers: handlers,\r\n            id: this.getDispatchId(),\r\n            done: this.done\r\n        };\r\n        const multipleDispatch = new _MultipleDispatch__WEBPACK_IMPORTED_MODULE_1__[\"MultipleDispatch\"](multipleDispatchOptions);\r\n        this.multipleDispatchQueue.push(multipleDispatch);\r\n    }\r\n    /* Распространяем состояние по подписчикам */\r\n    allocateState() {\r\n        this.views.map((view) => {\r\n            view(this.state);\r\n        });\r\n    }\r\n    getDispatchId() {\r\n        return this.lastDispatchId++;\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack:///./src/framework/Store.ts?");

/***/ }),

/***/ "./src/framework/StoreHandler.ts":
/*!***************************************!*\
  !*** ./src/framework/StoreHandler.ts ***!
  \***************************************/
/*! exports provided: StoreHandler */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"StoreHandler\", function() { return StoreHandler; });\nclass StoreHandler {\r\n    constructor(storeHandler) {\r\n        this.handler = storeHandler.handler;\r\n        this.sync = storeHandler.sync;\r\n    }\r\n    run(object, state, done) {\r\n        this.handler(object, state, done);\r\n    }\r\n    isSync() {\r\n        return this.sync;\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack:///./src/framework/StoreHandler.ts?");

/***/ }),

/***/ "./src/global/scripts/globalHelper.ts":
/*!********************************************!*\
  !*** ./src/global/scripts/globalHelper.ts ***!
  \********************************************/
/*! exports provided: globalHelper */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"globalHelper\", function() { return globalHelper; });\nconst globalHelper = (function Helper() {\r\n    function getViewPortSizes() {\r\n        const w = Math.max(document.documentElement.clientWidth, window.innerWidth || 0);\r\n        const h = Math.max(document.documentElement.clientHeight, window.innerHeight || 0);\r\n        return [w, h];\r\n    }\r\n    function clampTitles() {\r\n        let titles = document.querySelectorAll('.card_header__title > h3');\r\n        titles.forEach(function (title) {\r\n            $clamp(title, { clamp: 2, useNativeClamp: true });\r\n        });\r\n    }\r\n    function checkTouchDevice() {\r\n        const prefixes = ' -webkit- -moz- -o- -ms- '.split(' ');\r\n        const mq = function (query) {\r\n            return window.matchMedia(query).matches;\r\n        };\r\n        if (('ontouchstart' in window)) {\r\n            return true;\r\n        }\r\n        const query = ['(', prefixes.join('touch-enabled),('), 'heartz', ')'].join('');\r\n        return mq(query);\r\n    }\r\n    return {\r\n        getViewPortSizes: getViewPortSizes,\r\n        checkTouchDevice: checkTouchDevice,\r\n        clampTitles: clampTitles,\r\n    };\r\n})();\r\nglobalHelper.clampTitles();\r\n\n\n//# sourceURL=webpack:///./src/global/scripts/globalHelper.ts?");

/***/ }),

/***/ "./src/global/scripts/index.ts":
/*!*************************************!*\
  !*** ./src/global/scripts/index.ts ***!
  \*************************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _vendor_clamp_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./vendor/clamp.js */ \"./src/global/scripts/vendor/clamp.js\");\n/* harmony import */ var _vendor_clamp_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_vendor_clamp_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _globalHelper__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./globalHelper */ \"./src/global/scripts/globalHelper.ts\");\n/* harmony import */ var _components_general_header_header__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../components/general/header/header */ \"./src/components/general/header/header.ts\");\n/* harmony import */ var _components_library_camera_camera__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../components/library/camera/camera */ \"./src/components/library/camera/camera.ts\");\n/* harmony import */ var _components_library_camera_camera__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_components_library_camera_camera__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var _components_library_card_card__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../components/library/card/card */ \"./src/components/library/card/card.ts\");\n/* harmony import */ var _components_library_menu_menu__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../components/library/menu/menu */ \"./src/components/library/menu/menu.ts\");\n/* harmony import */ var _components_library_player_player__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../components/library/player/player */ \"./src/components/library/player/player.ts\");\n/* harmony import */ var _components_library_touch_elements_touch_elements__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../components/library/touch-elements/touch-elements */ \"./src/components/library/touch-elements/touch-elements.ts\");\n/* harmony import */ var _components_library_touch_elements_touch_elements__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(_components_library_touch_elements_touch_elements__WEBPACK_IMPORTED_MODULE_7__);\n/* harmony import */ var _framework_Store__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../framework/Store */ \"./src/framework/Store.ts\");\n/* harmony import */ var _framework_StoreHandler__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../framework/StoreHandler */ \"./src/framework/StoreHandler.ts\");\n/* harmony import */ var _framework_MultipleDispatch__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../../framework/MultipleDispatch */ \"./src/framework/MultipleDispatch.ts\");\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\n\n//# sourceURL=webpack:///./src/global/scripts/index.ts?");

/***/ }),

/***/ "./src/global/scripts/vendor/clamp.js":
/*!********************************************!*\
  !*** ./src/global/scripts/vendor/clamp.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/*!\r\n* Clamp.js 0.5.1\r\n*\r\n* Copyright 2011-2013, Joseph Schmitt http://joe.sh\r\n* Released under the WTFPL license\r\n* http://sam.zoy.org/wtfpl/\r\n*/\r\n(function(){window.$clamp=function(c,d){function s(a,b){n.getComputedStyle||(n.getComputedStyle=function(a,b){this.el=a;this.getPropertyValue=function(b){var c=/(\\-([a-z]){1})/g;\"float\"==b&&(b=\"styleFloat\");c.test(b)&&(b=b.replace(c,function(a,b,c){return c.toUpperCase()}));return a.currentStyle&&a.currentStyle[b]?a.currentStyle[b]:null};return this});return n.getComputedStyle(a,null).getPropertyValue(b)}function t(a){a=a||c.clientHeight;var b=u(c);return Math.max(Math.floor(a/b),0)}function x(a){return u(c)*\r\n    a}function u(a){var b=s(a,\"line-height\");\"normal\"==b&&(b=1.2*parseInt(s(a,\"font-size\")));return parseInt(b)}function l(a){if(a.lastChild.children&&0<a.lastChild.children.length)return l(Array.prototype.slice.call(a.children).pop());if(a.lastChild&&a.lastChild.nodeValue&&\"\"!=a.lastChild.nodeValue&&a.lastChild.nodeValue!=b.truncationChar)return a.lastChild;a.lastChild.parentNode.removeChild(a.lastChild);return l(c)}function p(a,d){if(d){var e=a.nodeValue.replace(b.truncationChar,\"\");f||(h=0<k.length?\r\n    k.shift():\"\",f=e.split(h));1<f.length?(q=f.pop(),r(a,f.join(h))):f=null;m&&(a.nodeValue=a.nodeValue.replace(b.truncationChar,\"\"),c.innerHTML=a.nodeValue+\" \"+m.innerHTML+b.truncationChar);if(f){if(c.clientHeight<=d)if(0<=k.length&&\"\"!=h)r(a,f.join(h)+h+q),f=null;else return c.innerHTML}else\"\"==h&&(r(a,\"\"),a=l(c),k=b.splitOnChars.slice(0),h=k[0],q=f=null);if(b.animate)setTimeout(function(){p(a,d)},!0===b.animate?10:b.animate);else return p(a,d)}}function r(a,c){a.nodeValue=c+b.truncationChar}d=d||{};\r\n    var n=window,b={clamp:d.clamp||2,useNativeClamp:\"undefined\"!=typeof d.useNativeClamp?d.useNativeClamp:!0,splitOnChars:d.splitOnChars||[\".\",\"-\",\"\\u2013\",\"\\u2014\",\" \"],animate:d.animate||!1,truncationChar:d.truncationChar||\"\\u2026\",truncationHTML:d.truncationHTML},e=c.style,y=c.innerHTML,z=\"undefined\"!=typeof c.style.webkitLineClamp,g=b.clamp,v=g.indexOf&&(-1<g.indexOf(\"px\")||-1<g.indexOf(\"em\")),m;b.truncationHTML&&(m=document.createElement(\"span\"),m.innerHTML=b.truncationHTML);var k=b.splitOnChars.slice(0),\r\n        h=k[0],f,q;\"auto\"==g?g=t():v&&(g=t(parseInt(g)));var w;z&&b.useNativeClamp?(e.overflow=\"hidden\",e.textOverflow=\"ellipsis\",e.webkitBoxOrient=\"vertical\",e.display=\"-webkit-box\",e.webkitLineClamp=g,v&&(e.height=b.clamp+\"px\")):(e=x(g),e<=c.clientHeight&&(w=p(l(c),e)));return{original:y,clamped:w}}})();\n\n//# sourceURL=webpack:///./src/global/scripts/vendor/clamp.js?");

/***/ })

/******/ });